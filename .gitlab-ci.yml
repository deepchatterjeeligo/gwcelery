variables:
  # Allow Celery to run as root, because everything runs as root under Docker.
  C_FORCE_ROOT: 'true'
  # Checking out the source is the exception rather than the rule because
  # most of our CI jobs run from tarballs or wheels or don't require the source
  # at all.
  GIT_STRATEGY: none

stages:
  - dist
  - test
  - deploy

# Build source distribution
sdist:
  image: python:3.7-slim
  stage: dist
  variables:
    GIT_STRATEGY: fetch
  before_script:
    # Versioneer will need access to the git tool.
    - apt-get -q update
    - apt-get -yq install --no-install-recommends git
  script:
    - python setup.py sdist
    - mv dist/* .
  artifacts:
    paths:
      - '*.tar.gz'

# Build binary distribution
bdist:
  image: python:3.7-slim
  stage: test
  script:
    - tar --strip-components 1 -xf *.tar.*
    - python setup.py bdist_wheel
    - mv dist/* .
  dependencies:
    - sdist
  artifacts:
    paths:
      - '*.whl'

# Build Docker container for dependencies
.dependencies: &dependencies
  stage: dist
  variables:
    GIT_STRATEGY: fetch
    IMAGE_TAG: $CI_REGISTRY_IMAGE/$CI_JOB_NAME:$CI_COMMIT_REF_NAME
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - |
      cat <<EOF > Dockerfile
      FROM python:${CI_JOB_NAME#*python}
      COPY requirements.txt .
      RUN pip --no-cache-dir install -r requirements.txt
      RUN rm -f requirements.txt
      EOF
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
    - if [ "${CI_COMMIT_TAG:0:1}" = "v" ]; then docker tag $IMAGE_TAG ${IMAGE_TAG%:*}:latest; docker push ${IMAGE_TAG%:*}:latest; fi
dependencies/python3.6:
  <<: *dependencies
dependencies/python3.7:
  <<: *dependencies

# Run unit tests and coverage measurement
.test: &test
  stage: test
  coverage: '/^TOTAL\s+.*\s+(\d+\.?\d*)%/'
  before_script:
    - apt-get update -qq && apt-get install -y -qq redis-server
  script:
    - tar --strip-components 1 -xf *.tar.*
    - pip install pytest-cov
    - python setup.py test --addopts='-vv --cov --cov-report=html --cov-report=term'
  dependencies:
    - sdist
  artifacts:
    paths:
      - htmlcov/
test/python3.6:
  image: $CI_REGISTRY_IMAGE/dependencies/python3.6:$CI_COMMIT_REF_NAME
  <<: *test
test/python3.7:
  image: $CI_REGISTRY_IMAGE/dependencies/python3.7:$CI_COMMIT_REF_NAME
  <<: *test

lint:
  image: $CI_REGISTRY_IMAGE/dependencies/python3.7:$CI_COMMIT_REF_NAME
  stage: test
  script:
    - tar --strip-components 1 -xf *.tar.*
    - pip install flake8 'pep8-naming!=0.8.0'
    - flake8 --show-source .
  dependencies:
    - sdist

# Build docker container for application itself
.docker: &docker
  stage: deploy
  script:
    - IMAGE_TAG=$CI_REGISTRY_IMAGE/${CI_JOB_NAME#*/}:$CI_COMMIT_REF_NAME
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - |
      cat <<EOF > Dockerfile
      FROM $CI_REGISTRY_IMAGE/dependencies/${CI_JOB_NAME#*/}:$CI_COMMIT_REF_NAME
      COPY *.whl .
      RUN pip install *.whl
      RUN rm -f *.whl
      USER nobody
      WORKDIR /tmp
      ENTRYPOINT ["gwcelery"]
      EOF
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
    - if [ "${CI_COMMIT_TAG:0:1}" = "v" ]; then docker tag $IMAGE_TAG ${IMAGE_TAG%:*}:latest; docker push ${IMAGE_TAG%:*}:latest; fi
  dependencies:
    - bdist
docker/python3.6:
  <<: *docker
docker/python3.7:
  <<: *docker

# Generate documentation
doc:
  image: python:3.7-slim
  stage: test
  before_script:
    - apt-get update -qq && apt-get install -y -qq graphviz
  script:
    - tar --strip-components 1 -xf *.tar.*
    - python setup.py build_sphinx
  dependencies:
    - sdist

# Publish coverage
pages:
  stage: deploy
  script:
    - mv htmlcov public/
  artifacts:
    paths:
      - public
    expire_in: 30 days
  only:
    - master
  dependencies:
    - test/python3.7

# Upload package to PyPI
pypi:
  stage: deploy
  image: python:3.7-slim
  script:
    - pip install twine
    - twine upload *.tar.* *.whl
  dependencies:
    - sdist
    - bdist
  only:
    - tags@emfollow/gwcelery

.deploy-common: &deploy-common
  stage: deploy
  image: kroniak/ssh-client
  only:
    - master@emfollow/gwcelery
  before_script:
    # Configure ssh known_hosts file and public/private key pair.
    - mkdir -p ~/.ssh
    - echo 'emfollow.ligo.caltech.edu,131.215.113.150 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAVKq+Y7sXfJVSEekUyw35FMUHiPgkryogaxMM0bsd2F4ZfXcH4x6HKQ+eByAJV53WeN9p17j+y69sV0/xNwjZc=' >> ~/.ssh/known_hosts
    - echo -e "${ID_RSA}" > ~/.ssh/id_rsa
    - echo "${ID_RSA_PUB}" > ~/.ssh/id_rsa.pub
    - chmod 0600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub

# Deploy on Caltech cluster
.deploy-start: &deploy-start
  <<: *deploy-common
  script: |
    ssh -T emfollow@emfollow.ligo.caltech.edu <<EOF
    set -ex
    mkdir -p ${CI_ENVIRONMENT_NAME} && cd ${CI_ENVIRONMENT_NAME}
    if [ -d .git ]; then git fetch; else git clone ${CI_PROJECT_URL} .; fi
    git checkout $CI_COMMIT_SHA
    echo CELERY_BROKER_URL=redis+socket://${PWD}/redis.sock > .env
    echo CELERY_CONFIG_MODULE=gwcelery.conf.${CI_ENVIRONMENT_NAME} >> .env
    echo FLOWER_URL_PREFIX=~\${USER}/${CI_ENVIRONMENT_NAME}/flower >> .env
    echo FLOWER_PORT=${FLOWER_PORT} >> .env
    pipenv sync
    pipenv run gwcelery condor resubmit
    EOF

# Deploy on Caltech cluster
.deploy-stop: &deploy-stop
  <<: *deploy-common
  script: |
    ssh -T emfollow@emfollow.ligo.caltech.edu <<EOF
    set -ex
    cd ${CI_ENVIRONMENT_NAME}
    pipenv run gwcelery condor rm
    EOF

deploy to production:
  <<: *deploy-start
  variables:
    FLOWER_PORT: '5555'
  when: manual
  environment:
    name: production
    on_stop: stop deployment on production
    url: https://ldas-jobs.ligo.caltech.edu/~emfollow/production/flower

deploy to playground:
  <<: *deploy-start
  variables:
    FLOWER_PORT: '5557'
  environment:
    name: playground
    on_stop: stop deployment on playground
    url: https://ldas-jobs.ligo.caltech.edu/~emfollow/playground/flower

stop deployment on production:
  <<: *deploy-stop
  when: manual
  environment:
    name: production
    action: stop

stop deployment on playground:
  <<: *deploy-stop
  when: manual
  environment:
    name: playground
    action: stop
